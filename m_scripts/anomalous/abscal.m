function [mu,rho,zed,fp,fpp,ray,comp,tran,amu,abs_edge, ...element_symbol,ifail]=abscal(e_name,energy,thick)% [mu,rho,zed,fp,fpp,ray,comp,tran,amu,abs_edge,element_symbol,ifail]=abscal(e_name,energy,thick)% calculates the output for absorb.m and gabs.m% the user should never have to call this routine directly% Copyright 1996 Anneli Munkholm & Sean M. Brennan.% Stanford Synchrotron Radiation Laboratory% Stanford Linear Accelerator Center, Stanford CA 94309% Bren@slac.stanford.edumu=[];rho=[];zed=[];fp=[];fpp=[];ray=[];comp=[];tran=[];amu=[]; ...abs_edge=[];element_symbol=[];ifail=[];if length( e_name ) <= 2		% try an element first	[zed,element_symbol]= element(e_name);    if zed > 0		[fp,fpp] = anomal( zed, energy );		[ray,comp] = raycomp( zed, energy );		[amu,rho,abs_edge] = atomdata( zed );% Summing fpp, ray and comp is correct for the attenuation		mu = (ff_to_mu * rho/amu) * (fpp + ray+ comp) ./ (energy);		ifail = 0;		mu_t= mu* thick;		tran= exp(-mu_t);	else		ifail = 1;	endelse	zed= 0;	abs_edge= 0;    ifail = rdlat(e_name);    if ifail == 0		[cd_strf,thetab,gamma,d_space,rho,vol] = ...			struct_f( 0, 0, 0, energy,293);		if energy == 0		    error( 'Energy undefined' );		end		if vol == 0		    error( 'Crystal volume undefined' );		end		mu = (1e4 * 2 * pi * energy * imag( cd_strf ) * gamma) / fhc;	else		ifail = 0;		[mu,rho] = ...		matlabs(e_name, energy );    end	mu_t= mu* thick;	tran= exp(-mu_t);end