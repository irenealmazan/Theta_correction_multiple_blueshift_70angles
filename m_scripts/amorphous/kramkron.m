function [fp,fpe] = kramkron(energy,fpp,atom,erange)% KRAMKRON Kramers-Kronig dispersion relationship%% Usage: [fp,fpe] = kramkron(energy,fpp,atom,{erange})%% Calculates the anomalous scattering factor f' from measured% f'' data, using the Kramers-Kroning integral. See FPPFIT% for a way to get f'' from absorption data. %% Input:%   energy      = vector of x-ray energies (eV)%   fpp         = vector of f'' values (electron units)%   zed         = atomic number of element of interest%   erange      = [emin emax], energy range over which %                 to calculate f' and over which the%                 measured f'' will be used; outside of %                 this range, Cromer-Liberman values are used%                 (optional; defaults to entire range of%                 input energy vector).% Output:%   fp          = calculated f' values (electron units)%   fpe         = energy scale for f' (only different from%                 the input energy if erange is specified).%% See also: FPPFIT, FPPFITG, XASTOASF% Based on FPCL.FOR, written by Karl Ludwig.% Matlab version 7-JUL-00 SMB bren@slac.stanford.edu% Code clean up and comments added, 15-MAR-02 Todd Hufnagel (hufnagel@jhu.edu)% (Modified from Hope's version to only use fpp, not XAS.) Do spline% fit/extrapolation at end to make fp energy scale same as input energy% scale.% 16-May-03 TCH Code clean-up, better comments. If user does not specify%           erange, then return f' over whole input E range (by doing a %           small extrapolation at the ends of the E range). Add time%           estimate.% Requires:% cromer.m, rel_cor.mat, justfpp.m, deriv.mglobal DISK_PATH DISK_END ANOMAL_FILES DISK_DELIM% Sanity checking on energy rangeif nargin<4	emin=min(energy);else    emin=erange(1);endif (nargin<4)|length(erange)==1	emax=max(energy);else    emax=erange(2);endif (emin<min(energy))|(emax>max(energy))    error('erange limits exceed range of input energy.')end    energy=energy(:)';fpp=fpp(:)';% make sure atom is a real elementzed = element(atom);% Get edge energies[adum,bdum, absedge] = atomdata( zed );absedge= absedge*1000;	% convert from keV to eV% load in kp_cor and rel_cor corrections to CL fpload([DISK_PATH,ANOMAL_FILES,DISK_DELIM,'crom_dir',DISK_END,'rel_cor']);warning offnpts= length(energy);% Calculate C-L values[fp_cl,fpp_cl]=cromer(zed,energy);% Sanity check%plot(energy,fpp_cl,energy,fpp)%title('Comparison of C-L and measured fpp')%xlabel('energy [eV]')%ylabel('fpp [#electrons]')%legend('Creomer- fpp','Measured fpp')%pause% Let's use Todd Hufnagel's deriv.m to get derivatives:nsm= 11;		% range over which smoothing occursidx= floor(nsm/2);yp= deriv(energy,fpp,1,nsm);% Todd pads yp with NaN's, we want to replace those % with a constant slopeyp= [ones(1,idx)*yp(idx+1) yp(idx+1:end-idx) ones(1,idx)*yp(end-idx)];ypp= deriv(energy,fpp,2,nsm);% Todd pads ypp with NaN's, we want to replace those % with zero second derivativeypp= [zeros(1,idx) ypp(idx+1:end-idx) zeros(1,idx)];disp('Calcuating f''. This takes a while, but is worth the wait.')fidx= find(energy>=emin&energy<=emax);% Make sure we don't get to close to beginning, endidx= find(fidx> 3 & fidx< length(energy)-3);eidx= fidx(idx);fp= zeros(1,length(eidx));ii= 0;		% counter for fppass=1;     % Counter for time estimate% Now we do the integralfor i=eidx,% Estimate how long this is all going to take    if pass==1        t0=clock;    elseif pass==2        t=etime(clock,t0);        est_time=length(eidx).*t;        minutes=floor(est_time/60);        seconds=round(rem(est_time,60));        if minutes>0            disp(['It should take me about ' num2str(minutes,'%0.5g') ' minutes to finish.'])        else            disp(['It should take me about  ' num2str(seconds,'%0.5g') ' seconds to finish.'])        end    end    %	disp(num2str(energy(i)))	ii= ii+1;	j= [i-2 i-1 i+1 i+2];%		disp(num2str(energy(j)))	ecur= [energy(j)- energy(i)]';	a= [ecur ecur.^2 ecur.^3 ecur.^4];	b= fpp(j)- fpp(i);	x=a\b(:);		% solve linear set of equations	% Do integration around energy(i) using Taylor Series Parameters	del_plus= energy(i+1)- energy(i);% This is reversed so the delta is + for the log()	del_minus= energy(i)- energy(i-1);	ans4=fpp(i)*(log(del_plus) ...		-log(del_minus)) ...		+x(1)*(energy(i+1)-energy(i-1)) ...		+x(2)*.5*(del_plus)^2 ...	    -x(2)*.5*(del_minus)^2 ...		+x(3)*.66667*(del_plus)^3 ...% This is +, not -, because del_minus has changed sign		+x(3)*.66667*(del_minus)^3 ...		+x(4)*1.5*(del_plus)^4 ...		-x(4)*1.5*(del_minus)^4;        num1=i-1;        num2=i+1;        ans1= valint(energy,fpp,yp,ypp,i,1,num1);        ans2= valint(energy,fpp,yp,ypp,i,num2,npts);        ans3= valsum(energy,fpp,yp,ypp,i,1,npts);% Now extend integration above data using C-L values% Integrate from e(npts) to 50*K-edge if K-edge fp% Integrate from e(npts) to 10.*K-edge if L_III-edge fp	if energy(1) >= absedge(4), 		a=energy(end);		b=50*absedge(1);		ans5= quad8('justfpp',a,b,[],[],energy(i),zed);	else		a= energy(end);		b= absedge(3);		ans5= quad8('justfpp',a,b,[],[],energy(i),zed);		a= absedge(3);		b= absedge(2);		ans5= ans5 + quad8('justfpp',a,b,[],[],energy(i),zed);		a= absedge(2);		b= absedge(1);		ans5= ans5 + quad8('justfpp',a,b,[],[],energy(i),zed);		a= absedge(1);		b= 10.*absedge(1);		ans5= ans5 + quad8('justfpp',a,b,[],[],energy(i),zed);	end% Integrate from L_III-edge to energy(1) if K-edge fp% Integrate from 0.4*M_v edge to e(1) if L_III edge fp	if energy(1) >= absedge(4),		a= absedge(4);		b= energy(1);		ans6= quad8('justfpp',a,b,[],[],energy(i),zed);	else		a= 0.4*absedge(9);		b= energy(1);		ans6= quad8('justfpp',a,b,[],[],energy(i),zed);	end	fp(ii)=(1/pi)*(ans3-ans1-ans2-ans4)+(2/pi)*(ans5+ans6);    pass=pass+1;endbeep % Wake 'em up% subtract relcor ala Ludwigfp= fp+CL_KPCOR(zed)-CL_RELCOR(zed);fpe=energy(eidx);if nargin<4                     % did the user specify erange?    fp=spline(fpe,fp,energy);   % if not, do a spline extrapolation    fpe=energy;                 % to match input energy rangeend% return column vectorsfp=fp(:);fpe=fpe(:);figure(1)plot(fpe,fp,energy,fp_cl)title('Comparison of Cromer-Liberman and calculated f''')xlabel('Energy (eV)')ylabel('f'' (electrons)')legend('Measured f''','Cromer-Liberman f''')warning onfunction answ= valint(energy,fpp,yp,ypp,i_now, imin, imax)% answ= valint(energy,fpp,yp,ypp,i_now, imin, imax)% energy= energy array% fpp= absorption array% yp= first derivative of fpp% ypp= second derivative of fpp% i_now= current value of index% imin, imax are integration limits (indeces)% Gives the value of the Kramers-Kronig Integral which has% 1/(E-E0) in the integrand.  It uses yp and ypp derived% from spline fite_now= energy(i_now);jmin= imin+1;jmax= imax-1;% sum over all but end pointsx1=mean([energy(imin:jmax-1);energy(jmin:jmax)],1);x2=mean([energy(jmin:jmax);energy(jmin+1:imax)],1);pre1=fpp(jmin:jmax)-yp(jmin:jmax).*energy(jmin:jmax) ...	+0.5*ypp(jmin:jmax).*energy(jmin:jmax).^2;pre2=yp(jmin:jmax)-energy(jmin:jmax).*ypp(jmin:jmax);pre3=0.5*ypp(jmin:jmax);delx= x2-x1;del2_minus= x2-e_now;del1_minus= x1-e_now;val1=log(del2_minus)-log(del1_minus);val2=(delx)+e_now.*log(del2_minus)-e_now.*log(del1_minus);val3=0.5*(del2_minus).^2-0.5*(del1_minus).^2 ...		+2.*e_now.*(delx)+(e_now^2).*log(del2_minus) ...		-(e_now^2).*log(del1_minus);answ= sum(pre1.*val1+pre2.*val2+pre3.*val3);% Now sum over first pointx1=energy(imin);x2=(energy(imin)+energy(imin+1))/2;delx= x2-x1;del2_minus= x2-e_now;del1_minus= x1-e_now;pre1=fpp(imin)-yp(imin)*energy(imin)+0.5*ypp(imin)*energy(imin)^2;pre2=yp(imin)-energy(imin)*ypp(imin);pre3=0.5*ypp(imin);val1=log(del2_minus)-log(del1_minus);val2=(delx)+e_now*log(del2_minus)-e_now*log(del1_minus);val3=0.5*(del2_minus)^2-0.5*(del1_minus)^2 ...		+2.*e_now*(delx)+(e_now^2)*log(del2_minus) ...		-(e_now^2)*log(del1_minus);answ=answ+pre1*val1+pre2*val2+pre3*val3;% Now sum over last pointx1=(energy(imax)+energy(imax-1))/2;x2=energy(imax);delx= x2-x1;del2_minus= x2-e_now;del1_minus= x1-e_now;pre1=fpp(imax)-yp(imax)*energy(imax)+0.5*ypp(imax)*energy(imax)^2;pre2=yp(imax)-energy(imax)*ypp(imax);pre3=0.5*ypp(imax);val1=log(del2_minus)-log(del1_minus);val2=(delx)+e_now*log(del2_minus) ...		-e_now*log(del1_minus);val3=0.5*(del2_minus)^2-0.5*(del1_minus)^2 ...		+2.*e_now*(delx)+(e_now^2)*log(del2_minus) ...		-(e_now^2)*log(del1_minus);answ=answ+pre1*val1+pre2*val2+pre3*val3;function answ= valsum(energy,fpp,yp,ypp,i_now, imin, imax)% answ= valsum(energy,fpp,yp,ypp,i_now, imin, imax)% energy= energy array% fpp= absorption array% yp= first derivative of fpp% ypp= second derivative of fpp% i_now= current value of index% imin, imax are integration limits (indeces)% Gives the value of the Kramers-Kronig Integral which has% 1/(E+E0) in the integrand.  It uses yp and ypp derived% from spline fite_now= energy(i_now);jmin= imin+1;jmax= imax-1;% sum over all but end pointsx1=mean([energy(imin:jmax-1);energy(jmin:jmax)],1);x2=mean([energy(jmin:jmax);energy(jmin+1:imax)],1);delx= x2-x1;x2_plus= x2+e_now;x1_plus= x1+e_now;pre1=fpp(jmin:jmax)-yp(jmin:jmax).*energy(jmin:jmax) ...	+0.5*ypp(jmin:jmax).*energy(jmin:jmax).^2;pre2=yp(jmin:jmax)-energy(jmin:jmax).*ypp(jmin:jmax);pre3=0.5*ypp(jmin:jmax);val1=log(x2_plus)-log(x1_plus);val2=(delx)-e_now.*log(x2_plus)+e_now.*log(x1_plus);val3=0.5*(x2_plus).^2-0.5*(x1_plus).^2 ...		-2.*e_now.*(delx)+(e_now^2).*log(x2_plus) ...		-(e_now^2).*log(x1_plus);answ= sum(pre1.*val1+pre2.*val2+pre3.*val3);% Now sum over first pointx1=energy(imin);x2=(energy(imin)+energy(imin+1))/2;delx= x2-x1;x2_plus= x2+e_now;x1_plus= x1+e_now;pre1=fpp(imin)-yp(imin)*energy(imin)+0.5*ypp(imin)*energy(imin)^2;pre2=yp(imin)-energy(imin)*ypp(imin);pre3=0.5*ypp(imin);val1=log(x2_plus)-log(x1_plus);val2=(delx)-e_now*log(x2_plus)+e_now*log(x1_plus);val3=0.5*(x2_plus)^2-0.5*(x1_plus)^2 ...		-2.*e_now*(delx)+(e_now^2)*log(x2_plus) ...		-(e_now^2)*log(x1_plus);answ=answ+pre1*val1+pre2*val2+pre3*val3;% Now sum over last pointx1=(energy(imax)+energy(imax-1))/2;x2=energy(imax);delx= x2-x1;x2_plus= x2+e_now;x1_plus= x1+e_now;pre1=fpp(imax)-yp(imax)*energy(imax)+0.5*ypp(imax)*energy(imax)^2;pre2=yp(imax)-energy(imax)*ypp(imax);pre3=0.5*ypp(imax);val1=log(x2_plus)-log(x1_plus);val2=(delx)-e_now*log(x2_plus) ...		+e_now*log(x1_plus);val3=0.5*(x2_plus)^2-0.5*(x1_plus)^2 ...		-2.*e_now*(delx)+(e_now^2)*log(x2_plus) ...		-(e_now^2)*log(x1_plus);answ=answ+pre1*val1+pre2*val2+pre3*val3;