function [ifu,inte,fac,fluf] = flunorm(k,icor,flu,limits,coh,inc,avef2,atden,s)% FLUNORM  %% [ifu,inte,datf,fluf] = flunorm(k,inte,flu,limits,coh,inc,avef2,atden,s)%% Determine normalization constant for experimental intensity data, for% the case where there is fluorescence (or other contributions to intensity)% that must be subtracted from the experimental data.% % Input:%% k          = vector of scattering vector magnitudes (inv. Angstroms)% icor       = experimental intensity (corrected)% flu        = fluorescense, corrected for absorption% limits     = [imin imax kmin kmax]%    imin, imax = limits of k used for integral normalization%    kmin, kmax = limits of k used for large angle normalization% coh        = independent coherent intensity <ff*>% inc        = independent incoherent intensity% avef2		 = avg. f^2% atden      = atomic density% s          = sample composition string%% Output:%% ifu		 = interference function (using integral normalization)% inte		 = normalized intensity% fluf       = normalization factor for fluorescence% fac       = normalization factor for scattered intensity% Copyright 2000, Todd Hufnagel (hufnagel@jhu.edu)% Originally by Ritva Serimaa% Extensively rewritten by Todd Hufnagel, 1/00 (no longer argument compatible w/ original)% 6/12/00 TCH Give user choice between two normalizations% 12-May-03 TCH Modified to accomodate changes in other routines in May '03% code clean-up. Comments added.% Use column vectors.k=k(:);icor=icor(:);flu=flu(:);coh=coh(:);inc=inc(:);avef2=avef2(:);% What are the ranges of k for normalization?imin = limits(1); imax = limits(2);kmin = limits(3); kmax = limits(4);% Estimate the scattering factor on the fluorescencej      = find(k >= imin & k <= imax);intobs = trapz(k(j),icor(j).*k(j).^2);intcal = trapz(k(j),(coh(j)+inc(j)).*k(j).^2);intflu = trapz(k(j),flu(j).*k(j).^2);[z,w]=strtoz(s);z=sum(z.*w)./sum(w);rho    = 2*pi^2*atden*z^2;m      = length(j);datf   = sum((coh(j)+inc(j)+(rho-intcal)/intflu*flu(j))./(icor(j)-intobs/intflu*flu(j)))/m;fluf = intobs/intflu + (rho-intcal)/datf/intflu;disp(sprintf('Scaling factor on fluorescence: %g%',fluf))% Do normalization and iterate until the user is happywhile isempty(fluf)==0;    % Calculate the normalization constant (with fluorescence subtracted)    % two ways.	int_fac=integral(k,imin,imax,icor-fluf*flu,coh,inc,atden);	la_fac=largeangle(k,kmin,kmax,icor-fluf*flu,coh,inc);    % Calculate the resulting interference functions    int_ifu=interfu(k,icor-flu*fluf,inc,coh,avef2,int_fac);	la_ifu=interfu(k,icor-flu*fluf,inc,coh,avef2,la_fac);    % Plot the results for inspection.    plot(k,la_ifu,'r',k,int_ifu,'b');title('i(k)');legend('Large angle','Integral');grid	disp(sprintf('Large angle constant = %g, integral constant = %g.',la_fac,int_fac))    disp(sprintf('Difference is %g%%',(la_fac-int_fac)/int_fac*100))    % Calculate the coherent scatttering using both normalization constants	int_inte=(icor-fluf*flu)*int_fac;	la_inte=(icor-fluf*flu)*la_fac;	oldfluf=fluf;	fluf  = input('New scale factor for fluorescence (<cr> to finish): ');end% Ask the user to choose between integral and large-angle normalization% constantsfluf=oldfluf;plot(k,la_ifu,'r',k,int_ifu,'b');title('i(k)');legend('Large angle','Integral');griddisp(sprintf('Large angle constant = %g, integral constant = %g.',la_fac,int_fac))disp(sprintf('Difference is %g%%',(la_fac-int_fac)/int_fac*100))nor = input('Use which one? (L/[I]): ','s');if (length(nor)==0) nor='integral'; endif (nor(1) == 'l' | nor(1) == 'L'),	 inte=la_inte;ifu=la_ifu;fac=la_fac;     disp('Large angle normalization selected.')	 else	 inte=int_inte;ifu=int_ifu;fac=int_fac;     disp('Integral normalization selected.')end