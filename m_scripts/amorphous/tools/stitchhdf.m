function [q,signal,center, rawcounts, monitor1]=stitchhdf(filename,scans,roidef,chan,deadtime);% STITCH.M%% Usage: [q,signal]=stitch(file,scans,steps,{roidef,chan,deadtime});%% Compiles multiple SUPER ADC files from SSRL into a single spectrum. Any% number of regions of interest (ROIs) may be defined. The number of counts% in each ROI can be taken to be either the area of a fit to the peak, % or a simple sum over a specified range of channels. The number of counts in% each ROI may (optionally) be corrected for detector deadtime, and may be% normalized (to a monitor channel, for instance). There is no requirement% that the individual scans have the same number of points, so STITCH can% be used to assemble complete spectra from partial scans. STITCH also% checks that the resulting q values are evenly spaced; if not, it does a % spline fit over the entire q range to ensure equally space steps.%% Input:% 	file    =   base file name (e.g. 'fred'). Note that the current%               directory must contain both the ADC spectra files (e.g.%               'fred001_01.*') as well as the corresponding SUPER file (e.g.%               'fred.001').%	scans   =   array of scan numbers (e.g. [3 4 5 6] or simply [3:6])%   roidef  =   data structure defining the method by which the%               number of counts in each ROI is determined:%                       roidef.method = 'bin', 'gauss', 'lor', or 'voigt'.%                       Bin is a sum over the specified range of channels;%                       the other three are fits to various peak shapes%                       (Gaussian, Lorenztian, and Voigt, respectively).%                       roidef.chan = [chan1 chan2] If binning, the two channels define%                           the limits of the bin. If fitting, the first channel is the%                           peak position, and the second is the estimated FWHM. (Note:%                           specifying the channels is optional; if not specified, you %                           will be prompted for graphical input.)%               If roidef is empty or not defined, STITCH returns a sum%               over all channels.%   chan        =   Specifies the channels of the SUPER scan file, as follows:%                   chan(1) = monitor (default = 3) Optional: If specified,%                   the data will be normalized to this channel. For no%                   normalization, specify chan(1)=0.%                   chan(2) = time (default = 2) Optional, but required for deadtime %                   correction.%	deadtime	=	deadtime in microseconds (optional)%% Output%	q			=	array of q values (inverse Å)%	signal     	=	array of ROI values (counts, or counts/monitor count)% 17-MAR-02 Todd Hufnagel, hufnagel@jhu.edu% 08-JUL-02 TCH %   (1) Allow specification of ratio channel and constant% 18-APR-04 TCH %   (1) Modify to allow specification of arbitary number of ROI%   (2) Fit a variety of peak shapes (Voigt, Gaussian, Lorentzian)%   (3) Determine number of steps in each scan automatically, from SUPER%   file%   (4) Removed option to normalize to constant% 24-APR-04 TCH%   (1) Minor change to use LOADSPEC instead of LOADSPECSSRL   % Requires: DEADTIME.M, LOADSPEC.M, PK_QVT.M, PK_QVTDF.Mglobal verbosen_adc_chan=950;             % 950 ADC channels by defaultif nargin<3                 % If ROI not specified, return a sum over all channels    roidef.method='bin';    roidef.chan=[1 n_adc_chan];    endif (nargin<4)|isempty(chan)	chan=[3 2];             % Default SUPER scaler channels: 3=monitor, 2=timeendif nargin<5                 % Default to no deadtime correction    deadtime=0;end	clear x y% How many regions of interest are there?nroi=size(roidef,2);for j=1:length(scans)    clear monitor time steps total    for n=1:nroi        roi.counts=[];        roi.truecounts=[];    end    % Load the q values, monitor, and time from the parent file	file=[filename,'.',num2str(scans(j),'%1.3d')];	[x,y]=loadspec(file,scans(j));	scan(j).q=x(:);    if (size(y,2)<max(chan))        error(['SUPER file has only ' num2str(size(y,2)) ' columns, but column ' num2str(max(chan)) ' was specified in CHAN.'])    end    scan(j).time=y(:,chan(2))./1000;      % Covert SUPER time value to time in seconds	scan(j).monitor=y(:,chan(1));           % Extract the number of monitor counts    scan(j).steps=size(y,1);             % Number of steps determined from length of SUPER file    % Load in the individual ADC spectra and calculate ROIs	    %waith = waitbar(0,['Loading ADC spectra for scan ' file]);    [energy, spectra]=rdhdf([filename num2str(scans(j),'%1.3d') '.hdf'],1);         for k=1:scan(j).steps        %waitbar(k/scan(j).steps,waith)        %file=[filename,num2str(scans(j),'%1.3d'),'_01.',num2str(k,'%1.3d')];		%[x,y]=loadspec(file,k);        x=[1:size(spectra,1)];        y=spectra(:,k);        scan(j).total(k)=sum(y);         for n=1:nroi            if lower(roidef(n).method(1))=='b'   % binning                if ~isfield(roidef(n),'chan')     % No ROI specified                    roidef(n).chan=getbinrange(x,y,n);                elseif isempty(roidef(n).chan)                    roidef(n).chan=getbinrange(x,y,n);                else                        % ROI specified				    if ~(roidef(n).chan(1)<roidef(n).chan(2))                        error(['Invalid bounds for ROI ' numstr(n)])                    end                                    end                scan(j).roi(n).counts(k)=sum(y(roidef(n).chan(1):roidef(n).chan(2)));                                center=[];                % SH 6/2/05  seeing if the tails of the peaks can help                % normalize                                %hilim=roidef(n).chan(2);                %lolim=roidef(n).chan(1);                %bkgnd=(mean(y(lolim-50:lolim)))%+mean(y(hilim:hilim+50)))/2                %corr=(hilim-lolim)*bkgnd;                                %scan(j).roi(n).counts(k)=scan(j).roi(n).counts(k)-corr;                                %end additions                                            elseif lower(roidef(n).method(1))=='g'   % Fit a Gaussian peak                if ~isfield(roidef(n),'chan')         % No peak specified                    roidef(n).chan=getbinrange(x,y,n);                elseif isempty(roidef(n).chan)                    roidef(n).chan=getbinrange(x,y,n);                end			    xt=x(roidef(n).chan(1):roidef(n).chan(2));			    yt=y(roidef(n).chan(1):roidef(n).chan(2));			    [scan(j).roi(n).counts(k),chan_max,fity]=peakarea(xt,yt,0);                                                %SH 12-03-04 finding centroid of stitched peaks and writing                %them to an output file                range=roidef(n).chan;                offset=roidef(n).chan(1);                center(k,j)=chan_max;                if mod(k,15)==0                    plot(xt,fity,x(roidef(n).chan(1)-30:roidef(n).chan(2)+30),y(roidef(n).chan(1)-30:roidef(n).chan(2)+30));                    title(['area is: ' num2str(scan(j).roi(n).counts(k))]);                    pause(.01)                end                    %SH end additions                                            elseif lower(roidef(n).method(1))=='l'   % Fit a Lorentzian peak                if ~isfield(roidef(n),'chan')        % No peak specified                    roidef(n).chan=getbinrange(x,y,n);                elseif isempty(roidef(n).chan)                    roidef(n).chan=getbinrange(x,y,n);                end			    xt=x(roidef(n).chan(1):roidef(n).chan(2));			    yt=y(roidef(n).chan(1):roidef(n).chan(2));			    [scan(j).roi(n).counts(k),chan_max,fity]=peakarea(xt,yt,1);                            %SH 2-12-07                range=roidef(n).chan;                offset=roidef(n).chan(1);                center(k,j)=chan_max;                %plot(xt,fity,x(roidef(n).chan(1)-30:roidef(n).chan(2)+30),y(roidef(n).chan(1)-30:roidef(n).chan(2)+30));                                       elseif lower(roidef(n).method(1))=='v'   % Fit a Voigt peak                if ~isfield(roidef(n),'chan')         % No peak specified                    roidef(n).chan=getbinrange(x,y,n);                elseif isempty(roidef(n).chan)                    roidef(n).chan=getbinrange(x,y,n);                end			    xt=x(roidef(n).chan(1):roidef(n).chan(2));			    yt=y(roidef(n).chan(1):roidef(n).chan(2));			    [scan(j).roi(n).counts(k),chan_max,fity]=peakarea(xt,yt,2);                           %SH 2-12-07                range=roidef(n).chan;                offset=roidef(n).chan(1);                center(k,j)=chan_max;                %plot(xt,fity,x(roidef(n).chan(1)-30:roidef(n).chan(2)+30),y(roidef(n).chan(1)-30:roidef(n).chan(2)+30));                                                   else                    error(['Unknown fit/bin method for ROI ' num2str(n)]);            end	% if lower(roidef(n).met1hod(1))=='b'              end % for n    end % for k=1:steps(j)    %close(waith)                % Make everything into column vectors    for n=1:nroi        scan(j).roi(n).counts=scan(j).roi(n).counts(:);    end       scan(j).monitor=scan(j).monitor(:);	scan(j).time=scan(j).time(:);	scan(j).total=scan(j).total(:);	     %SH 6-14-07    clear temp montemp    temp = scan(j).roi(n).counts;    montemp = scan(j).monitor;    if length(scan(j).roi(n).counts)<386         temp(length(temp)+1:386)=zeros;        montemp(length(montemp)+1 : 386)=zeros;    end    rawcounts(:,j) = temp(1:386);    monitor1(:,j) = montemp(1:386);            % Do the deadtime correction. The correction must be based on the total counts    % going into the detector, so we have to use that as the input for DEADCOR. But    % we only return the signal, so we assume that the deadtime correction factor is    % the same for both signal and total counts.    if deadtime~=0            scan(j).truetotal=deadcor(scan(j).total,[],scan(j).time,deadtime);    end    for n=1:nroi        if deadtime~=0            scan(j).roi(n).truecounts=scan(j).roi(n).counts.*scan(j).truetotal./scan(j).total;        else            scan(j).roi(n).truecounts=scan(j).roi(n).counts;        end    %    plot(scan(j).roi(n).truecounts);disp([num2str(n) ' truecounts']);pause    %    plot(scan(j).roi(n).truecounts./scan(j).monitor);disp([num2str(n) ' truecounts/mon']);pause        % Normalize the signal to the number of monitor counts, if needed            if chan(1)~=0            scan(j).roi(n).signal=scan(j).roi(n).truecounts./scan(j).monitor;        else            scan(j).roi(n).signal=scan(j).roi(n).truecounts;        end    %    plot(scan(j).roi(n).signal);disp([num2str(n) ' signal']);pause    end    		end % for j=1:length(scans)waith = waitbar(0,['Averaging spectra']);% Reorganize all of the data into two arrays, one for the q values and one% for the ROI datafor j=1:length(scans)    if (j==1)        q=scan(j).q(:)';        for n=1:nroi            allscans(n).signal=scan(j).roi(n).signal(:)';        end        else        q=[q scan(j).q(:)'];        for n=1:nroi            allscans(n).signal=[allscans(n).signal(:)' scan(j).roi(n).signal(:)'];        end        end    end % Sort all of the data into ascending q order[q i]=sort(q);for n=1:nroi    allscans(n).signal=allscans(n).signal(i);end% Identify duplicate q values, and average the signal at those pointsq=q(:);qdiff=diff(q);%tempq=q(1);ndups=1;clear tempsumj=0;for i=1:length(qdiff)    waitbar(i/length(qdiff),waith)    if qdiff(i)~=0   % The next point is different from this one        j=j+1;        tempq(j)=q(i);    % assign the next q value         for n=1:nroi            if ndups>1  % there were duplicate points                 temproi(n).signal(j)=(tempsum(n).signal(j)+allscans(n).signal(i))./ndups;             else       % there were no duplicate points                 temproi(n).signal(j)=allscans(n).signal(i);             end             end             clear tempsum        % and clear the temporary sum         ndups=1;     else           % The next point is the same as this one         for n=1:nroi             if ndups==1                 tempsum(n).signal(j+1)=allscans(n).signal(i);             else                 tempsum(n).signal(j+1)=tempsum(n).signal(j+1)+allscans(n).signal(i);             end             end         ndups=ndups+1;     end end       clear roi for n=1:nroi     roi(n).signal=temproi(n).signal; end % need to do the last point separately, if not same as the penultimate point % in this case, by definition there is no need to average if q(length(q)-1)-q(length(q))~=0         tempq(j+1)=q(length(q));     for n=1:nroi         roi(n).signal(j+1)=allscans(n).signal(length(q));     end     end q=tempq;  close(waith) % % Check to make sure that the q values are evenly spaced...deltaq=q(2)-q(1);unevenspacing=0;for j=2:length(q)	if (abs((q(j)-q(j-1))-deltaq)>0.001)		unevenspacing=1;		disp(['Unevenly spaced q values at q=' num2str(q(j-1)) ',' num2str(q(j))])	endend% ...and if not, do a spline fit to make them evenly spaced.if unevenspacing	disp('Doing spline fit to make q values evenly spaced.')	newq=[q(1):deltaq:q(end)];    for n=1:nroi    	roi(n).signal=spline(q,roi(n).signal,newq);    end        q=newq;end% Generate the output vectorsq=q(:);signal=ones(length(q),nroi);for n=1:nroi    signal(:,n)=roi(n).signal(:);end    function [area,chan_max,fity]=peakarea(xarray,yarray,shape) %  PEAKAREA - Area of a peak fit to data%%  Input:   xpos  = array of x-data (angle, for instance)%           ypos  = array of y-data (intensity, for instance)%			shape = shape parameter (0=Gaussian, 1=Lorentzian, 2=Voigt [default])%%  Output:  area  = area under peak%  functions called:%  leasqr  (the actual fitting routine)%  pk_qvt   (the function)%  pk_qvtdf  (the jacobian of the function)% 21-APR-2004 Gutted FITVOIGT to produce this function for use in STITCH.% Here are the FITVOIGT comments:%  Created: 29-APR-1997 %  Author :  Sean M. Brennan (Bren@SLAC.stanford.edu)%  Modifications:%  14-JUL-99 Todd Hufnagel, JHU (hufnagel@jhu.edu)%    1) Make default plot linear scale%    2) Make default 1/sqrt(y) weighting%    3) Print out all fit results to command window%    4) Plot correct final result%    5) Cleaned up help comments%  10-MAR-02 Todd Hufnagel%    1) Also return area under peak%global verbose% tell leasqr what you want:  verbose(1)= 0;  % Don't print outputverbose(2)= 0;  % Don't plot intermediate resultsverbose(3)= 0;  % Linear scale (log scale would be 0)verbose(4)= 0;  % Don't stop prematurelyxarray= xarray(:);yarray= yarray(:);npts= length(xarray);[peak,index]= max(yarray);   % find peak of yarrayxpos= xarray(index);         % that's the xval, too.% Now find speak width, sigma% delta_y=yarray(2:npts)-yarray(1:npts-1);% delta_x=xarray(2:npts)-xarray(1:npts-1);% int_diff=delta_y./delta_x;% [dum l_peak]=max(int_diff(1:index-1));% [dum r_peak]=min(int_diff(index:npts-1));% r_peak=r_peak+index;% sigma=xarray(r_peak)-xarray(l_peak);%SH 6-6-07%new way to find peak width that is more reliable.halfheight = peak/2;lowlim = halfheight - halfheight*.3;highlim = halfheight + halfheight*.3;temp = find(yarray > lowlim & yarray < highlim);lowx = find(xarray(temp)< xpos);highx = find(xarray(temp) > xpos);lowxmid = round(length(lowx)/2);highxmid = round(length(highx)/2);lowxvals = xarray(temp(lowx));highxvals = xarray(temp(highx));sigma = highxvals(highxmid) - lowxvals(lowxmid);lambda= [xpos peak sigma shape 0 0];constrain=0.001*ones(6,1);  % only 3 parameters, fit them allconstrain(5)=0;constrain(6)=0; % no backgroundif (shape==0)|(shape==1)    % Gaussian or Lorentzian    constrain(4)=0;else    shape=0.5;  % Guess 50% Gaussianend    % Weighting. For equal weights, make this wt= ones(npts,1);wt= ones(size(xarray));%plofity=leasqr(xarray,yarray,lambda,'pk_qvt',0.001,50,wt,constrain,'pk_qvtdf');%SH 12-3-04 spit out location of maximumsplxarray=min(xarray):0.1:max(xarray);splfity=spline(xarray,fity,splxarray);[value_max,index_max]=max(splfity);chan_max=splxarray(index_max);%SH end correctionsarea= trapz(xarray,fity);function chan=getbinrange(x,y,roi)                    figure;			        plot(x,y);				    disp(['Click on limits of ROI ' num2str(roi) '.'])				    [peakx,peaky,button]=ginput(1);				    %loweri=closest(x,round(peakx)); SH 2-12-07 closest seems not to be a function				    loweri=round(peakx);                    [peakx,peaky,button]=ginput(1);                    upperi=round(peakx);				    %upperi=closest(x,round(peakx)); same as above				    if (loweri>upperi)					    temp=loweri;					    loweri=upperi;					    upperi=temp;				    end                    chan=[loweri upperi];    				s=sprintf('ROI %d range: Channels %d to %d.',roi,chan(1),chan(2));    				disp(s)			        close(gcf)