function [q,intensity]=stitch(filename,scans,steps,ratio,deadtime,method,peak);% STITCH.M%% Usage: [q,intensity]=stitch(filename,scans,steps,{ratio,deadtime,method,peak});%% Compiles multitlple ADC files into a single spectrum. The signal can either be taken to% be the area of a Gaussian fit to the elastic peak, or a simple sum over a specified% range of channels. The number of counts is then corrected for detector deadtime, and % may be normalized to (for instance) the number of monitor counts. Also checks that the % resulting q values are evenly spaced; if not, a spline fit is done over the entire range% of q to make q evenly spaced. (Used for data taken during the SSRL March '02 run.)%% Input:% 	filename	=	base file name (e.g. 'ta4_100')%	scans		=	array of scan numbers (e.g. [3 4 5 6] or simply [3:6])%	steps		=	array of numbers of steps in each scan (=#points-1)%	ratio		=	[column constant], normalization for data, where%					column = channel from parent file to divide into data (=0 for none)%					constant = constant to be divided into data (=0 for none). Note%					that for SSRL data, the clock signal/262144 gives time in seconds.%	deadtime	=	deadtime in microseconds (=0 for no deadtime correction)%	method		=	method for extracting signal. Can either be 'fit', to fit the%					elastic peak to a Gaussian (default), or 'bin' to select a range of%					channels to sum.%	peak		=	if fitting to a Gaussian (method='fit'), then peak is the %					approximate location of the elastic peak (channel #); if not%					specified, then the peak is specified by cursor input. If%					binning to calculate the signal, then peak=[loweri upperi], where%					loweri and upperi are the lower and upper boundaries (channel #)%					of the elastic peak. Again, if not specified, these can be input%					via the cursor.%% Output%	q			=	array of q values (inverse Å)%	intensity	=	array of intensity values (arb. units)% %hi % 17-MAR-02 Todd Hufnagel, hufnagel@jhu.edu% 08-JUL-02 TCH Allow specification of ratio channel and constant% Requires: DEADTIME.M, LOADSPECSSRL.Mglobal verboseif nargin<4	ratio=[0 0];elseif(length(ratio)<2)	ratio(2)=0;endif nargin<5	deadtime=0;endif nargin<6	method='fit';endif nargin<7	peakspecified=0;else	peakspecified=1;end	clear x yfor j=1:length(scans)% Load the q values in from the parent file	file=[filename,'.',num2str(scans(j),'%1.3d')];	disp(['Loading data from file ' file])	[x,y]=loadspecssrl(file,scans(j));	q=x';	time=y(:,2)./262144;	monitor=y(:,4);	total=y(:,7);	if (ratio(1)~=0)		divisor=y(:,ratio(1));	end% Load in the individual ADC spectra and fit peak		for k=1:steps(j)+1		file=[filename,num2str(scans(j),'%1.3d'),'_01.',num2str(k,'%1.3d')];		[x,y]=loadspecssrl(file,k);		if peakspecified			if (lower(method)=='fit')				maxi=peak;			else				loweri=peak(1);				upperi=peak(2);			end		else			figure;			plot(x,y);			if (lower(method(1:3))=='fit')				disp(['Click on elastic peak position.'])				[peakx,peaky,button]=ginput(1);				maxval=round(peakx);				maxi=closest(x,maxval);				s=sprintf('Elastic peak position = %-8.6g',maxi);				disp(s)				peakspecified=1;				peak=maxi;			else				disp(['Click on region to bin for signal.'])				[peakx,peaky,button]=ginput(1);				loweri=closest(x,round(peakx));				[peakx,peaky,button]=ginput(1);				upperi=closest(x,round(peakx));				if (loweri>upperi)					temp=loweri;					loweri=upperi;					upperi=loweri;				end				peak(1)=loweri;				peak(2)=upperi;				peakspecified=1;								s=sprintf('Range = %-8.6g to %-8.6g.',loweri,upperi);				disp(s)			end			close(gcf)		end						total(k)=sum(y);				if (lower(method)=='bin')% 			size(y)% 			loweri% 			upperi			counts(k)=sum(y(loweri:upperi));		else			x=x(maxi-20:maxi+20);			y=y(maxi-20:maxi+20);			counts(k)=gaussarea(x,y);		end		end% Make everything into column vectors		counts=counts(:);	monitor=monitor(:);	time=time(:);	total=total(:);	divisor=divisor(:);	% Do the deadtime correction. The correction must be based on the total counts% going into the detector, so we have to use that as the input for DEADCOR. But% we only return the signal, so we assume that the deadtime correction factor is% the same for both signal and total counts.	if deadtime~=0		truetotal=deadcor(total,monitor,time,deadtime);		truecounts=counts.*truetotal./total;	else		truecounts=counts;	end	% Calculate the counting rate	if (ratio(1)~=0)		signal=truecounts./divisor;%	else%		signal=truecounts./monitor;	end	if (ratio(2)~=0)		signal=signal./ratio(2);	end	%	signal=truecounts./monitor;%	plot(q,monitor./time)%	pause	% Look for duplicate q values; if found, average the signal% at those points.	if j==1		x1=q;		y1=signal;	else		x1=x1(:)';		y1=y1(:)';		x2=q;		y2=signal;		x2=x2(:)';		y2=y2(:)';		for k=1:length(x1)			for l=1:length(x2)				if(x1(k)==x2(l))					y1(k)=((y1(k)+y2(l))./2);					if exist('dups')						dups=[dups l];					else						dups=l;					end				end			end		end		if exist('dups')				x2(dups)=[];			y2(dups)=[];		end			x1=[x1 x2];			y1=[y1 y2];	end	clear counts truecounts monitor time signal	end% Generate the output vectorsq=x1;intensity=y1;% Check to make sure that the q values are evenly spaced...deltaq=q(2)-q(1);unevenspacing=0;for j=2:length(q)	if (abs((q(j)-q(j-1))-deltaq)>0.001)		unevenspacing=1;		disp(['Unevenly spaced q values at q=' num2str(q(j-1)) ',' num2str(q(j))])	endend% ...and if not, do a spline fit to make them evenly spaced.if unevenspacing	disp('Doing spline fit to make q values evenly spaced.')	newq=[q(1):deltaq:q(end)];	newintensity=spline(q,intensity,newq);plot(q,intensity,'o',newq,newintensity,'-')	q=newq(:);	intensity=newintensity(:);endfunction area=gaussarea(xarray,yarray) %%  input:   x-array%           y-array%  output:  area%  functions called:%  leasqr  (the actual fitting routine)%  gauss   (the function)%  dfgauss  (the jacobian of the function)%  Created: 5-Mar-1997 %  Author :  Sean M. Brennan (Bren@SLAC.stanford.edu)%  Modified: 10-Mar-2002%            Todd Hufnagel (hufnage@jhu.edu)%            Returns only area under peak global verbose% tell leasqr what you want:  verbose(1)= 0;  % Don't print outputverbose(2)= 0;  % Don't plot intermediate resultsverbose(3)= 0;  % Log scaleverbose(4)= 0;  % Don't stop prematurelyxarray= xarray(:);yarray= yarray(:);npts= length(xarray);[peak,index]= max(yarray);   % find peak of yarrayxpos= xarray(index);         % that's the xval, too.% Now find sigmadelta_y=yarray(2:npts)-yarray(1:npts-1);delta_x=xarray(2:npts)-xarray(1:npts-1);int_diff=delta_y./delta_x;[dum l_peak]=max(int_diff(1:index-1));[dum r_peak]=min(int_diff(index:npts-1));r_peak=r_peak+index;sigma=xarray(r_peak)-xarray(l_peak);lambda= [xpos peak sigma];constrain=0.001*ones(3,1);  % only 3 parameters, fit them allwt= ones(npts,1);  % equal weights.  If noisy data, this could be 1/sqrt(yarray) instead[fity,lambdaf,kvg,iter,corp,covp,covr,stdresid,Z,r2]= ...	leasqr(xarray,yarray,lambda,'gauss',.001,50,wt,constrain,'dfgauss');area= trapz(xarray,fity);