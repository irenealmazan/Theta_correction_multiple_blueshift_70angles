function dydx=deriv(x,y,order,npts)% DERIV - numerical calculation of derivative of data%% Usage: dydx=deriv(x,y,{order,npts})%% DERIV calculates derivatives of (x,y) pair data sets.% Derivatives of up to third order can be calculated; note% that a zeroth-order derivative is equivalent to smoothing% the data. Uses the method of Savitzky and Golay, which is% (conceptually) a fit of a cubic polynomial to the data (over% a limited range) followed by a calculation of the derivative.%% Inputs: x,y   = (x,y) data pairs%         order = order of derivative (default=1, can be 0-3)%         npts  = range of points for fit (default=5)%                 (allowed values are 5, 7, 9 and 11)%% Outputs: dydx = derivative of data. Note that the first and last%                 (npts-1)/2 points are not computed and are%                 assigned NaN.% TCH 4-23-98% TCH 4-29-98 Added check for dimensions of input vectors% Copyright 1998 Todd Hufnagel% Department of Materials Science and Engineering% Johns Hopkins Univerity, Baltimore, MD 21218% hufnagel@jhu.edu% References: A. Savitzky and M.J.E. Golay, Anal. Chem. 36, 1627 (1964)% Several errors in Savitzky and Golay are corrected in the following:% J. Steinier et al., Analytical Chemistry 44, 1906-1909 (1972)% H. H. Madden, Analytical Chemistry 50, 1383-1386 (1978)if (nargin<2)	error('Not enough input arguments.')elseif (nargin<3)	order=1;	npts=5;elseif (nargin<4)	npts=5;endif ((npts~=5)&(npts~=7)&(npts~=9)&(npts~=11))	error('Number of points must be 5, 7, 9, or 11')endif ((order~=0)&(order~=1)&(order~=2)&(order~=3))	error('Derivative order must be 0, 1, 2, or 3')end% Check whether x and y are row vectors, and if not, make them so[x,xrow]=row(x);[y,yrow]=row(y);% Ensure that x and y are the same lengthif (length(x)~=length(y));error('Input vectors must be the same length');end% Set up the derivative array, omitting points at endsdydx=y;hw=(npts-1)/2;first=hw+1;last=length(dydx)-hw;dydx(1:first-1)=NaN;dydx(last+1:length(dydx))=NaN;deltax=x(2)-x(1);% Now fetch the appropriate set of coefficients[coef,norm]=coefficients(order,npts);% Calculate the derivativefor i=first:last	dydx(i)=sum(y(i-hw:i+hw).*coef)/(norm.*deltax^order);end% Make sure the derivative has the same shape as y vectorif ~yrow	dydx=column(dydx);end				function [coeff,norm]=coefficients(order,npts)% Note that these come from Tables 1, 4, 6, and 8 of Savitzky and Golay.% Note also there there are several errors in Savitzky and Golay's tables% that have been fixed here (see references above). All of the following % have been tested on cubic polynomials and seem to work OK.if (order==0)	if (npts==5)		coeff=[-3 12 17 12 -3];		norm=35;	elseif (npts==7)		coeff=[-2 3 6 7 6 3 -2];		norm=21;	elseif (npts==9)		coeff=[-21 14 39 54 59 54 39 14 -21];		norm=231;	else		coeff=[-36 9 44 69 84 89 84 69 44 9 -36];		norm=429;	endelseif (order==1)	if (npts==5)		coeff=[1 -8 0 8 -1];		norm=12;	elseif(npts==7)		coeff=[22 -67 -58 0 58 67 -22];		norm=252;	elseif(npts==9)		coeff=[86 -142 -193 -126 0 126 193 142 -86];		norm=1188;	else		coeff=[300 -294 -532 -503 -296 0 296 503 532 294 -300];		norm=5148;	endelseif (order==2)	if (npts==5)		coeff=[2 -1 -2 -1 2];		norm=7;	elseif (npts==7)		coeff=[5 0 -3 -4 -3 0 5];		norm=42;	elseif (npts==9)		coeff=[28 7 -8 -17 -20 -17 -8 7 28];		norm=462;	elseif (npts==11)		coeff=[15 6 -1 -6 -9 -10 -9 -6 -1 6 15];		norm=429;	endelse	if (npts==5)		coeff=[-1 2 0 -2 1];		norm=2;	elseif (npts==7)		coeff=[-1 1 1 0 -1 -1 1];		norm=6;	elseif (npts==9)		coeff=[-14 7 13 9 0 -9 -13 -7 14];		norm=198;	else		coeff=[-30 6 22 23 14 0 -14 -23 -22 -6 30];		norm=858;	endendreturnfunction [y,rowwise]=row(x)% ROW - returns the input array as a row vector%% Usage: [y,rowwise]=row(x)%% ROW returns the 1-D input vector as a row vector,% and indicates whether the input array was a row% vector to begin with.%% Input:	x = one-dimensional array (row or column)%% Output:	y = row vector version of x. If x was a row%				vector (or not 1-D), y returns x unchanged.%			rowwise	= 1 if x was a row vector%					= 0 if x was a column vector%					= -1 if x was not one-dimensional% TCH 4-29-98% Copyright 1998 Todd C. Hufnagel% Johns Hopkins University% hufnagel@jhu.edu[m,n]=size(x);if (m==1)		% input array was a row vector	rowwise=1;	y=x;elseif (n==1)	% input array was a column vector	rowwise=0;	y=reshape(x,1,m);else			% input array was not 1-D	rowwise=-1;	y=x;endfunction [y,columnwise]=column(x)% COLUMN - returns the input array as a column vector%% Usage: [y,columnwise]=column(x)%% column returns the 1-D input vector as a column vector,% and indicates whether the input array was a column% vector to begin with.%% Input:	x = one-dimensional array (row or column)%% Output:	y = column vector version of x. If x was a column%				vector (or not 1-D), y returns x unchanged.%			columnwise	= 1 if x was a column vector%						= 0 if x was a row vector%						= -1 if x was not one-dimensional% TCH 4-29-98% Copyright 1998 Todd C. Hufnagel% Johns Hopkins University% hufnagel@jhu.edu[m,n]=size(x);if (n==1)		% input array was a column vector	columnwise=1;	y=x;elseif (m==1)	% input array was a row vector	columnwise=0;	y=reshape(x,1,n);else			% input array was not 1-D	columnwise=-1;	y=x;end		