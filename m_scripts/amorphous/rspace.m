function [r,rdf,rrdf,pcf] = rspace(k,ifu,p,dampfunc,atden);% RSPACE  Calculate real space results%% Usage:%	[r,rdf,rrdf,pcf] = rspace(k,ifu,p,dampfunc,atden)%% Calculates the radial distribution function, reduced% radial distribution function, and pair correlation% function.%% Input:%   k        = array of scattering vector values (inv. Angstroms)%   ifu      = reduced interference function i(k)%   p        = damping parameters (see below)%   dampfunc = damping function string. Can be:%              'gauss' D(k)=exp(-p(1).k.^2)%              'delgauss' D(k)=exp(-p(1).*(k-kmin).^2)%              'varalpha' D(k)=exp(log(100)./(p(2)-p(1)).^2.*(k-p(1)).^2)%              'lorch' D(k)=p(1)./(pi.*k).*sin(pi.*k./p(1))%              'none' D(k)=ones(size(k)) (i.e. no damping)%   atden    = atomic density in atoms/^3%% Output:%   r       = array of real-space distances ()%   rdf     = radial distribution function%   rrdf    = reduced radial distribution function%   pcf     = pair correlation function% Todd Hufnagel (hufnagel@jhu.edu) 5-2-00% Originally by R. Serimaa% TCH 7-27-99 Automatically reshape input vectors into rows% TCH 7-27-99 Plot results% TCH 7-27-99 Eliminate specification of # of points for FFT% TCH 5-2-00 Eliminate specification of kstep; code clean-up% TCH 12-May-03 Incorporate reducedrdf, radial, and paircor into this file.% Also add code for global PROBE.% TCH 06-Aug-03 Include teststep in this file; increased # points for FT% Check for which PROBE we are using% Default is PROBE=0, x-rays, k values are k=4*pi*sin(theta)/lambda% Also coulde have PROBE=1, electrons, k values are s=2*sin(theta)/lambda   global PROBE     if isempty(PROBE) PROBE=0;end    if ~((PROBE==0)|(PROBE==1))       error('Unknown setting of global PROBE! (Should be 0 for x-rays or 1 for electrons.)')   end% Make sure we're using column vectorsk=k(:);ifu=ifu(:);[r,rrdf] = reducedrdf(k,ifu,p,dampfunc);rdf = radial(r,rrdf,atden);pcf = paircor(r,rdf,atden);% Make sure we return column vectorsr=r(:);rrdf=rrdf(:);rdf=rdf(:);pcf=pcf(:);%--------------------------------------------------------------------------function [r,rrdf] = reducedrdf(k,ifu,p,dampfunc);% REDUCEDRDF  difference radial distribution function%% [r,rrdf] = reducedrdf(k,ifu,p,dampfunc)%% Input:% k			= k-scale% ifu		= reduced interference function, i(k)% p			= damping parameters (see below)% dampfunc	= damping function string. Can be:%				'gauss' D(k)=exp(-p(1).k.^2)%				'delgauss' D(k)=exp(-p(1).*(k-kmin).^2)%				'varalpha' D(k)=exp(log(100)./(p(2)-p(1)).^2.*(k-p(1)).^2)%				'lorch' D(k)=p(1)./(pi.*k).*sin(pi.*k./p(1))%				'none' D(k)=ones(size(k)) (i.e. no damping)%% Output:% r			= r-scale% rrdf		= reduced radial distribution function% Todd Hufnagel (hufnagel@jhu.edu) 5-2-00% Originally by R. Serimaa% TCH 7-27-99 Automatically reshape input vectors into rows% TCH 7-27-99 Input i(k), not k*i(k)% TCH 7-27-99 Eliminate specification of # of points for FFT% TCH 6-24-02 Added option for various damping functions% TCH 9-Aug-02 Changed minimum npts to 4*length(k) (useful for xtalline materials)% Reference: H. Ishii, Ph.D. thesis, Stanford University, May 2002.% Make sure we're using column vectorsk=k(:);ifu=ifu(:);kik=k.*ifu;% Choose number of points for FFT. The default (and minimum) is 4096 (2^12),% but we check to make sure that it is much larger than length(k)n=12;while (8.*length(k)>2^n)	n=n+1;endnpts=2^n;delk = (max(k)-min(k))/length(k);[r,red] = foursine(k,kik,delk,p,dampfunc,npts);rrdf = 2/pi*r.*red;% Make sure we return column vectorsr=r(:);rrdf=rrdf(:);%--------------------------------------------------------------------------function rdf = radial(r,rrdf,atden);% RADIAL  radial distribution function (RDF)%% rdf = radial(r,dif,atden)% input:% r     = r-scale% rrdf   = reduced RDF% atden = atomic density% output:% RDF   = values of radial distribution function in points rrdf = 4*pi*atden*r.^2 + rrdf;%--------------------------------------------------------------------------function pcf = paircor(r,rdf,atden);% PAIRCOR  pair correlation function% % pcf = paircor(r,rdf,atden)% input:% r   = r-scale% RDF = radial distribution function% output:% pcf = pair correlation functionpcf = zeros(size(r));j = find(r > 0.5);pcf(j) = rdf(j)./(4*pi*atden*r(j).^2);%--------------------------------------------------------------------------function [r,fy] = foursine(k,y,delk,p,dampfunc,n)% FOURSINE  Fourier sine transform % % [r,fy] = foursine(k,y,delk,p,dampfunc,n)%% Input:% k   		= arguments of the function to be transformed% y    		= function to be transformed% delk 		= step of interpolated k-scale% p			= damping parameters (see below)% dampfunc	= damping function string. Can be:%				'gauss' D(k)=exp(-p(1).k.^2)%				'delgauss' D(k)=1 for k<p(2), D(k)=exp(-p(1).*(k-p(2)).^2) for k>=p(2)%				'varalpha' D(k)=exp(log(100)./(p(2)-p(1)).^2.*(k-p(1)).^2)%				'lorch' D(k)=p(1)./(pi.*k).*sin(pi.*k./p(1))%				'none' no damping (D(k)=ones(size(k)))% n   		= total number of points in the function y to be Fourier transformed. If%				necessary, y is extrapolated at the low end to k=0, and then a%				a spline interpolation is done to give n points in the function%				to be transformed.%        		% Output:% r		= r-scale% fy	= Fourier sine transform of y% Todd Hufnagel (hufnagel@jhu.edu)% Originally by R. Serimaa% 6-24-02 TCH Added choice of damping functions% 6-25-02 TCH Added check for damping function going negative% 12-May-03 TCH Added code for PROBE (choice of s or k)global PROBE% Calculate damping function and apply it to datadampfunc=lower(dampfunc);	% Gaussian dampingif (dampfunc(1)=='g')	dam=exp(-p(1).*k.^2);	kmax=max(k);elseif (dampfunc(1)=='d')	% Delayed Gaussian damping function	dam=ones(size(k));	j=find(k>=p(2));	dam(j)=dam(j).*exp(-p(1).*(k(j)-p(2)).^2);	kmax=max(k);elseif (dampfunc(1)=='v')	% Variable alpha damping function	dam = ones(size(k));	j = find(k >= p(1));	dam(j) = dam(j).*exp(-log(100)/(p(2)-p(1))^2*(k(j)-p(1)).^2);	kmax=p(2);elseif (dampfunc(1)=='l')	% Lorch damping	dam=p(1)./(pi.*k).*sin(pi.*k./p(1));	kmax=p(1);elseif (dampfunc(1)=='n')	% No damping	dam=ones(size(k));	kmax=max(k);else	error('Unknown damping function.')end% Check for damping function going negativej=find(dam<=0);if ~isempty(j)	dam(j)=zeros(size(dam(j)));	disp('Damping function was negative at some points; set to zero there.')endplot(k,dam);axis([0 max(k) 0 1.1]);xlabel('k');ylabel('Damping function')%saveigor([k dam], '~/documents/igor/thesis_ch_data_analysis/lorch.txt', 'lorch_q  lorch');y = y.*dam;% extrapolate to zero and make k evenly spaced (if required)[ki,yi]=extrapol(k,y,delk,kmax);m    = max(size(ki));fy   = -imag(fft(yi,max(m,n)));fy = fy(1:n/2)*delk;% calculate r; depends on input x valuesswitch PROBE    case 0                  % x-rays        delr = 2*pi/delk/max(n,m);    case 1        delr = 1./delk./max(n,m);    otherwise        error('Unknown value of global PROBE! (Should be 0 for x-rays or 1 for electrons)')endr  = ([0:1:length(fy)-1]*delr)'; %--------------------------------------------------------------------------function [ki,yi]=extrapol(k,y,delk,kmax)% EXTRAPOL       extrapolate y(k) to zero and interpolate %                to equidistant k-scale% [ki,yi]=extrapol(k,y,delk,kmax)% input:% k         argument array% y         function to be extrapolated% delk      new step% kmax      maximum of output k-scale% output:% ki        new argument array% yi        function values at ki% TCH 8-Aug-02 Fixed array bug for non-evenly-spaced datak=k(:);y=y(:);m = max(size(k));mnew = stepsto0(k,delk);if (teststep(k,delk) & mnew >= 0),%   disp('equidistant steps, no interpolation')   if min(k) > 0,      knew = [0:1:mnew]*delk;% note: linear extrapolation to zero      ynew = y(1)/min(k)*knew;      ki = [knew k']';    	  yi = [ynew y']';   else      ki = k;    yi = y;   end;else    disp('Variable steps in x values; interpolating to even spacing.')   if min(k) > 0,		k = [0 k'];     		y = [0 y'];%		m = m + 1;   end	k2=[delk:delk:k(2)-delk];	y2=interp1(k,y,k2);		 	y=[y2 y]; 	k=[k2 k];	delk=(max(k)-min(k))./length(k);	ki=[0:1:length(k)-1].*delk;	yi = spline(k,y,ki);		ki=ki(:);	yi=yi(:);	disp('Interpolated data; press any key to continue.')	plot(k,y,'o',ki,yi,'-');pauseend;%--------------------------------------------------------------------------function nnew= stepsto0(k,delk)% STEPSTO0     calculates the number of steps needed to extrapolate %              an argument array k to zero with steps delk%              Returns a negative value if%              the number of steps is not integer% nnew= stepsto0(k,delk)% input:% k            array, elements in increasing order, k(1) > 0% output:% nnew         number of extrapolation steps. nnew = floor(min(k)/delk);if nnew-ceil(min(k)/delk) > 0, nnew = -nnew; end%--------------------------------------------------------------------------function equalsteps = teststep(k,delk)% TESTSTEP   tests if steps of k are of equal width (delk)% teststep(k,delk)% input:% k           argument array% delk        step% output:% equalsteps  logical variable, which is 1 if equidistant steps and 0 otherwisem = max(size(k));j = 2:m;varsteps = find(abs(k(j)-k(j-1)-delk) > 0.01*delk);equalsteps = isempty(varsteps);